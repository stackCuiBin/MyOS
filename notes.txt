第一课 进阶操作系统
1，什么是操作系统？
	Windows Unix Linux MacOS iOS
	操作系统是直接运行于硬件之上的计算机程序
	操作系统是用于管理和控制计算机的硬件与软件资源
	操作系统为用户软件的开发提供必要的服务和接口
	
2，BIOS - Base Input & Output System
	BIOS是计算机上电后第一个运行的程序
	BIOS首先检测硬件状态，检测通过后立即进行硬件初始化
	BIOS会在内存中建立中断向量表(提供硬件访问的方法)
	BIOS最后将控制权交由主引导程序执行
	
	注意
		BIOS不是软件(software)，而是固件(firmware)
		固件是固化于硬件中的程序，在硬件出厂前已经烧写固定
		
3，系统启动流程(X86架构)
	上电 -> 运行BIOS -> 硬件初始化 -> 建立中断向量表 -> 加载运行主引导程序 
	-> 软件初始化 -> 加载运行操作系统内核 -> 系统初始化 -> ...
	
4，BIOS是怎么运行起来的呢？
	BIOS的运行机制
		BIOS存储于ROM中，地址映射为0xF0000 - 0xFFFFF (实地址)
		BIOS的入口地址为：0xFFFF0
		硬件电路的特殊设计使得：开机后，CPU从0xFFFF0处开始执行
		
	BIOS最后的使命
		按照用户设置扫描各个存储介质(光驱，软驱，U盘，等)
		发现主引导程序后，将主引导区的中主引导程序载入内存
		主引导程序在内存中的入口地址为0x7c00
		将控制权交由主引导程序执行(jmp 0x7c00)
		
5，思考
	BIOS如何在存储介质中寻找主引导区？
	如何判断引导区中有没有主引导程序？
	
	主引导区(MBR: Master Boot Record)
		位置：位于存储介质的最开始位置处，大小为512字节
		特点：前512字节的最后2个有效字节为0x55aa
		数据：0x55aa之前的数据被视为主引导程序
	
	更详细的系统启动流程(x86架构)
	上电 -> 运行BIOS -> 光驱存在MBR? -> 软驱存在MBR? -> 硬盘存在MBR? -> ERROR
	 					yes |			yes|			yes|
	--------------------------------------------------------
	|-> 加载主引导程序 Addr:0x7c00 -> jmp 0x7c00 -> 软件初始化 
	-> 加载运行操作系统内核 -> 系统初始化 -> run
	
第2课 Hello DTOS
1，问题
	主引导程序是软件还是固件？如果时软件，那么由谁开发？如何开发？
	
	主引导程序
		一段存储在主引导区(MBR)中的有效代码
		并不固化于硬件，属于操作系统代码的一部分
		启动操作系统内核的桥梁，由汇编程序写成
		代码总量不能超过512个字节(包含0x55aa)
		
2，课程实验
	编写一个主引导程序(汇编语言)
	可独立运行于x86架构的主机(无操作系统)
	运行后在屏幕上打印"hello DTOS"
	
	实现思路
		将关键寄存器的值设置为0 (mov ax, 0)
		定义需要打印的数据(db "hello DTOS")
		打印预定义好的字符数据(int 0x10)
		
	汇编小贴士
		mov:赋值操作，将右操作数赋值给左操作数
			mov ax, 0 ;将0赋值给ax寄存器
		int:触发中断
			int 0x10 ;触发0x10中断，对屏幕进行操作
		hlt:停止运行，CPU进入暂停状态，不执行任何操作
			hlt ;使程序进入睡眠状态
		汇编中地址的访问方式：段地址：段内偏移地址
			mov byte [0xb800:0x01], 0x07 ; 0xb800:0x01 -> 0xb800 + 0x01
		标签
			用于标识后续指令的地址(可等同为C语言中的标签)
		$ VS $$
			$表示当前指令行地址，$$表示当前汇编段起始地址
			
		中断调用 VS 函数调用
			1: mov bx, 0x0f
			2: mov ah, 0x0e
			3: mov al, 'c'
			4: int 0x10
			
			printf("%c", 'c');
			1和2行相当于参数"%c"
			3行中的'c'相当于'c'
			int 0x10功能标识，相当于printf
			
3，如何测试程序？
	解决方案设计
		将汇编代码编译为二进制机器码(nasm)
		创建虚拟盘(bximage)
		将二进制代码写入虚拟盘起始位置(dd)
		在虚拟机中将虚拟盘作为启动盘执行(vmware)
		
	实验原材料
		nasm
			nasm boot.asm -o boot.bin
		bximage
			bximage a.img -q -fd -size=1.44
		dd
			dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc
			
小结
	主引导程序的代码量不能超过512字节
	主引导程序需要使用汇编语言开发
	主引导程序中可以通过BIOS中断使用硬件功能
	主引导程序运行于实模式(地址都是实际的物理地址)
	
第3课 调试环境搭建
1，问题
	如何调试主引导区的代码？
	
2，Bochs(另一款优秀的虚拟机软件)
	专业模拟x86架构的虚拟机
	开源且高度可移植，由C++编写完成
	支持操作系统开发过程中的断点调试
	通过简单配置就能够运行于绝大多数主流的操作系统
	
	小贴士
		确定bochs的安装路径(which bochs)
		安装vgabios (apt-get install vgabios)
		确定vgabios的安装路径(whereis vgabios)
		
	bochs的启动文件
	启动bochs虚拟机
		显示方式：bochs -f bochsrc_file
		隐式方式：bochs (在当前目录下查找以下三个文件)
			.bochsrc
			bochsrc
			bochsrc.txt
			
3，bochs中的常用调试命令
	b(break)			设置断点				b 0x7c00
	c(continue)			继续执行				c
	s(step)				单步执行				s
	info b(break)		查看当前所有断点		info b
	info cpu			查看当前CPU状态		info cpu
	r(reg)				查看常规寄存器状态	r
	sreg				查看段寄存器状态		sreg
	x /Nuf expression	查看内存中的数据		x /2bx 0x7c00
	trace on[off]		开关：打印执行的指令	trace on
	trace-reg on[off]	开关：打印寄存器的值	trace-reg on
	
第4课 主引导程序的扩展-上
1，限制
	主引导程序的代码量不能超过512字节
	
	突破限制的思路
		主引导程序
			完成最基本的初始化工作
			从存储介质中加载程序到内存中
			将控制权交由新加载的程序执行
			......
		
2，问题
	主引导程序如何加载存储介质中的其它程序？
	
	文件系统
		存储介质上组织文件数据的方法(数据组织的方式)
		FAT12文件格式
			数据区
			根目录区
			FAT2
			FAT1
			引导扇区
			
	文件系统示例
		FAT12是DOS时代的早期文件系统
		FAT12结构非常简单，一直沿用于软盘
		FAT12的基本组织单位
			字节(byte)：基本数据单位
			扇区(Sector)：磁盘中的最小数据单元
			簇(Cluster)：一个或多个扇区
			
	解决方案
		使用FAT12对软盘进行格式化
		编写可执行程序(Loader)，并将其拷贝到软盘中
		主引导程序(Boot)在文件系统中查找Loader
		将Loader复制到内存中，并跳转到入口处执行
		
	实验：往虚拟软盘中写入文件
		原材料：FreeDOS，Bochs，bximage
		步骤：
			创建虚拟软盘data.img
			在FreeDos中进行格式化(FAT12)
			将data.img挂载到Linux中，并写入文件
			
	下一步的工作
		Boot查找目标文件(Loader)，并读取文件的内容
		
3，深入FAT12文件系统
	FAT12文件系统由引导区，FAT表，根目录项表和文件数据区组成
		扇区位置		长度			内容
		  0			1(512 B)	引导程序
		  1			9(4608 B)	FAT表1
		  10		9(4608 B)	FAT表2
		  19		14(9728 B)	目录文件项
		  33		----		文件数据
		  
	FAT12的主引导区
		主引导区存储的比较重要的信息是文件系统的类型，文件系统逻辑扇区总数，
		每簇包含的扇区数，等。主引导区最后以0x55aa两个字节作为结束，共占用一个扇区。
		
4，实验：读取data.img中的文件系统信息
	步骤：
		创建Fat12Header结构体类型
		使用文件流读取前512字节的内容
		解析并打印相关的信息
		
	实验结论
		(1) FreeDos中的format程序在格式化软盘的时候自动在第0扇区生成了一个主引导程序，
			这个主引导程序只打印一个字符串
		(2) 文件格式和文件系统都是用于定于数据如何存放的规则，只要遵循这个规则就能够成功
			读写目标数据
			
小结
	主引导程序的代码量不能超过512字节
	可以通过主引导程序加载新程序的方式突破限制
	加载新程序需要依赖于文件系统
	FAT12是一种早期用于软盘的简单文件系统
	FAT12文件系统的重要信息存储于0扇区
	
第5课 主引导程序的扩展-下
1，问题
	如何在FAT12根目录中查找是否存在目标文件？
	
	根目录区的大小和位置
		大小：	BPB_RootEntCnt * sizeof(RootEntry)
				----------------------------------
						BPB_BytsPerSec
		位置：在第19个扇区的起始位置
	
	FAT12文件系统中的根目录区
		根目录区由目录项构成，每一个目录项代表根目录中的一个文件索引。
		数据成员			偏移		长度		描述
		DIR_Name		0x00	0x0B	文件名8字节，扩展名3字节
		DIR_Attr		0x0B	0x01	文件属性
		Reserve			0x0C	0x0A	保留位
		DIR_WrtTime		0x16	0x02	最后一次写入时间
		DIR_WrtDate		0x18	0x02	最后一次写入日期
		DIR_FstClus		0x1A	0x02	文件开始的簇号(在FAT12中1簇是1扇区)
		DIR_FileSize	0x1C	0x04	文件大小
		(RootEntry数据结构共32字节)
		
	实验：读取FAT12文件系统的根目录信息
		步骤：
			创建RootEntry结构体类型
			使用文件流顺序读取每个目录项的内容
			解析并打印相关的信息
			
2，目录项中的关键成员
	DIR_Name
		文件名(用于判断是否为目标文件)
	DIR_FstClus
		文件数据起始存储位置(用于确定读取位置)
	DIR_FileSize
		文件大小(用于确定读取的字节数)
		
3，FAT表-FAT12的数据组织核心
	FAT1和FAT2是相互备份的关系，数据内容完全一致
	FAT表是一个关系图，记录了文件数据的先后关系
	每一个FAT表占用12比特
	FAT表的前2个表规定不能使用
	
	FAT表中的先后关系
		以簇(扇区)为单位存储文件数据
		每个表项(vec[i])表示文件数据的实际位置(簇)
			DIR_FstClus表示文件第0簇(扇区)的位置
			vec[DIR_FstClus]表示文件第1簇(扇区)的位置
			vec[vec[DIR_FstClus]]表示文件第2簇(扇区)的位置
			......
			
	实验：加载FAT12中的文件数据
		步骤：
			在根目录区查找目标文件对应的项
			获取目标文件的起始簇号和文件大小
			根据FAT表中记录的逻辑先后关系读取数据
	小贴士一
		FAT表中每个表项只占用12比特(1.5字节)
		FAT表一共记录了BPB_BytsPerSec * 9 * 2/3个表项
		可以使用一个short表示一个表项的值
		如果表项值大于等于0xFF8，则说明已经到达最后一个簇
		如果表项值等于0xFF7，则说明当前簇已经损坏
	小贴士二
		数据区起始簇(扇区)号为33，地址为0x4200
		数据区起始地址所对应的编号为2(不为0)
		因此，DIR_FstClus对应的地址为：
			0x4200 + (DIR_FstClus - 2) * 512

小结
	FAT12根目录区记录了文件的起始簇号和长度
	通过查找根目录区能够确定是否存在目标文件
	FAT12文件数据的组织使用了单链表的思想
		文件数据离散的分布于存储介质中
		文件数据通过FAT项进行关联

