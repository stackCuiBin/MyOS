第一课 进阶操作系统
1，什么是操作系统？
	Windows Unix Linux MacOS iOS
	操作系统是直接运行于硬件之上的计算机程序
	操作系统是用于管理和控制计算机的硬件与软件资源
	操作系统为用户软件的开发提供必要的服务和接口
	
2，BIOS - Base Input & Output System
	BIOS是计算机上电后第一个运行的程序
	BIOS首先检测硬件状态，检测通过后立即进行硬件初始化
	BIOS会在内存中建立中断向量表(提供硬件访问的方法)
	BIOS最后将控制权交由主引导程序执行
	
	注意
		BIOS不是软件(software)，而是固件(firmware)
		固件是固化于硬件中的程序，在硬件出厂前已经烧写固定
		
3，系统启动流程(X86架构)
	上电 -> 运行BIOS -> 硬件初始化 -> 建立中断向量表 -> 加载运行主引导程序 
	-> 软件初始化 -> 加载运行操作系统内核 -> 系统初始化 -> ...
	
4，BIOS是怎么运行起来的呢？
	BIOS的运行机制
		BIOS存储于ROM中，地址映射为0xF0000 - 0xFFFFF (实地址)
		BIOS的入口地址为：0xFFFF0
		硬件电路的特殊设计使得：开机后，CPU从0xFFFF0处开始执行
		
	BIOS最后的使命
		按照用户设置扫描各个存储介质(光驱，软驱，U盘，等)
		发现主引导程序后，将主引导区的中主引导程序载入内存
		主引导程序在内存中的入口地址为0x7c00
		将控制权交由主引导程序执行(jmp 0x7c00)
		
5，思考
	BIOS如何在存储介质中寻找主引导区？
	如何判断引导区中有没有主引导程序？
	
	主引导区(MBR: Master Boot Record)
		位置：位于存储介质的最开始位置处，大小为512字节
		特点：前512字节的最后2个有效字节为0x55aa
		数据：0x55aa之前的数据被视为主引导程序
	
	更详细的系统启动流程(x86架构)
	上电 -> 运行BIOS -> 光驱存在MBR? -> 软驱存在MBR? -> 硬盘存在MBR? -> ERROR
	 					yes |			yes|			yes|
	--------------------------------------------------------
	|-> 加载主引导程序 Addr:0x7c00 -> jmp 0x7c00 -> 软件初始化 
	-> 加载运行操作系统内核 -> 系统初始化 -> run
	
第2课 Hello DTOS
1，问题
	主引导程序是软件还是固件？如果时软件，那么由谁开发？如何开发？
	
	主引导程序
		一段存储在主引导区(MBR)中的有效代码
		并不固化于硬件，属于操作系统代码的一部分
		启动操作系统内核的桥梁，由汇编程序写成
		代码总量不能超过512个字节(包含0x55aa)
		
2，课程实验
	编写一个主引导程序(汇编语言)
	可独立运行于x86架构的主机(无操作系统)
	运行后在屏幕上打印"hello DTOS"
	
	实现思路
		将关键寄存器的值设置为0 (mov ax, 0)
		定义需要打印的数据(db "hello DTOS")
		打印预定义好的字符数据(int 0x10)
		
	汇编小贴士
		mov:赋值操作，将右操作数赋值给左操作数
			mov ax, 0 ;将0赋值给ax寄存器
		int:触发中断
			int 0x10 ;触发0x10中断，对屏幕进行操作
		hlt:停止运行，CPU进入暂停状态，不执行任何操作
			hlt ;使程序进入睡眠状态
		汇编中地址的访问方式：段地址：段内偏移地址
			mov byte [0xb800:0x01], 0x07 ; 0xb800:0x01 -> 0xb800 + 0x01
		标签
			用于标识后续指令的地址(可等同为C语言中的标签)
		$ VS $$
			$表示当前指令行地址，$$表示当前汇编段起始地址
			
		中断调用 VS 函数调用
			1: mov bx, 0x0f
			2: mov ah, 0x0e
			3: mov al, 'c'
			4: int 0x10
			
			printf("%c", 'c');
			1和2行相当于参数"%c"
			3行中的'c'相当于'c'
			int 0x10功能标识，相当于printf
			
3，如何测试程序？
	解决方案设计
		将汇编代码编译为二进制机器码(nasm)
		创建虚拟盘(bximage)
		将二进制代码写入虚拟盘起始位置(dd)
		在虚拟机中将虚拟盘作为启动盘执行(vmware)
		
	实验原材料
		nasm
			nasm boot.asm -o boot.bin
		bximage
			bximage a.img -q -fd -size=1.44
		dd
			dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc
			
小结
	主引导程序的代码量不能超过512字节
	主引导程序需要使用汇编语言开发
	主引导程序中可以通过BIOS中断使用硬件功能
	主引导程序运行于实模式(地址都是实际的物理地址)
	
第3课 调试环境搭建
1，问题
	如何调试主引导区的代码？
	
2，Bochs(另一款优秀的虚拟机软件)
	专业模拟x86架构的虚拟机
	开源且高度可移植，由C++编写完成
	支持操作系统开发过程中的断点调试
	通过简单配置就能够运行于绝大多数主流的操作系统
	
	小贴士
		确定bochs的安装路径(which bochs)
		安装vgabios (apt-get install vgabios)
		确定vgabios的安装路径(whereis vgabios)
		
	bochs的启动文件
	启动bochs虚拟机
		显示方式：bochs -f bochsrc_file
		隐式方式：bochs (在当前目录下查找以下三个文件)
			.bochsrc
			bochsrc
			bochsrc.txt
			
3，bochs中的常用调试命令
	b(break)			设置断点				b 0x7c00
	c(continue)			继续执行				c
	s(step)				单步执行				s
	info b(break)		查看当前所有断点		info b
	info cpu			查看当前CPU状态		info cpu
	r(reg)				查看常规寄存器状态	r
	sreg				查看段寄存器状态		sreg
	x /Nuf expression	查看内存中的数据		x /2bx 0x7c00
	trace on[off]		开关：打印执行的指令	trace on
	trace-reg on[off]	开关：打印寄存器的值	trace-reg on
	
