第一课 进阶操作系统
1，什么是操作系统？
	Windows Unix Linux MacOS iOS
	操作系统是直接运行于硬件之上的计算机程序
	操作系统是用于管理和控制计算机的硬件与软件资源
	操作系统为用户软件的开发提供必要的服务和接口
	
2，BIOS - Base Input & Output System
	BIOS是计算机上电后第一个运行的程序
	BIOS首先检测硬件状态，检测通过后立即进行硬件初始化
	BIOS会在内存中建立中断向量表(提供硬件访问的方法)
	BIOS最后将控制权交由主引导程序执行
	
	注意
		BIOS不是软件(software)，而是固件(firmware)
		固件是固化于硬件中的程序，在硬件出厂前已经烧写固定
		
3，系统启动流程(X86架构)
	上电 -> 运行BIOS -> 硬件初始化 -> 建立中断向量表 -> 加载运行主引导程序 
	-> 软件初始化 -> 加载运行操作系统内核 -> 系统初始化 -> ...
	
4，BIOS是怎么运行起来的呢？
	BIOS的运行机制
		BIOS存储于ROM中，地址映射为0xF0000 - 0xFFFFF (实地址)
		BIOS的入口地址为：0xFFFF0
		硬件电路的特殊设计使得：开机后，CPU从0xFFFF0处开始执行
		
	BIOS最后的使命
		按照用户设置扫描各个存储介质(光驱，软驱，U盘，等)
		发现主引导程序后，将主引导区的中主引导程序载入内存
		主引导程序在内存中的入口地址为0x7c00
		将控制权交由主引导程序执行(jmp 0x7c00)
		
5，思考
	BIOS如何在存储介质中寻找主引导区？
	如何判断引导区中有没有主引导程序？
	
	主引导区(MBR: Master Boot Record)
		位置：位于存储介质的最开始位置处，大小为512字节
		特点：前512字节的最后2个有效字节为0x55aa
		数据：0x55aa之前的数据被视为主引导程序
	
	更详细的系统启动流程(x86架构)
	上电 -> 运行BIOS -> 光驱存在MBR? -> 软驱存在MBR? -> 硬盘存在MBR? -> ERROR
	 					yes |			yes|			yes|
	--------------------------------------------------------
	|-> 加载主引导程序 Addr:0x7c00 -> jmp 0x7c00 -> 软件初始化 
	-> 加载运行操作系统内核 -> 系统初始化 -> run
	
第2课 Hello DTOS
1，问题
	主引导程序是软件还是固件？如果时软件，那么由谁开发？如何开发？
	
	主引导程序
		一段存储在主引导区(MBR)中的有效代码
		并不固化于硬件，属于操作系统代码的一部分
		启动操作系统内核的桥梁，由汇编程序写成
		代码总量不能超过512个字节(包含0x55aa)
		
2，课程实验
	编写一个主引导程序(汇编语言)
	可独立运行于x86架构的主机(无操作系统)
	运行后在屏幕上打印"hello DTOS"
	
	实现思路
		将关键寄存器的值设置为0 (mov ax, 0)
		定义需要打印的数据(db "hello DTOS")
		打印预定义好的字符数据(int 0x10)
		
	汇编小贴士
		mov:赋值操作，将右操作数赋值给左操作数
			mov ax, 0 ;将0赋值给ax寄存器
		int:触发中断
			int 0x10 ;触发0x10中断，对屏幕进行操作
		hlt:停止运行，CPU进入暂停状态，不执行任何操作
			hlt ;使程序进入睡眠状态
		汇编中地址的访问方式：段地址：段内偏移地址
			mov byte [0xb800:0x01], 0x07 ; 0xb800:0x01 -> 0xb800 + 0x01
		标签
			用于标识后续指令的地址(可等同为C语言中的标签)
		$ VS $$
			$表示当前指令行地址，$$表示当前汇编段起始地址
			
		中断调用 VS 函数调用
			1: mov bx, 0x0f
			2: mov ah, 0x0e
			3: mov al, 'c'
			4: int 0x10
			
			printf("%c", 'c');
			1和2行相当于参数"%c"
			3行中的'c'相当于'c'
			int 0x10功能标识，相当于printf
			
3，如何测试程序？
	解决方案设计
		将汇编代码编译为二进制机器码(nasm)
		创建虚拟盘(bximage)
		将二进制代码写入虚拟盘起始位置(dd)
		在虚拟机中将虚拟盘作为启动盘执行(vmware)
		
	实验原材料
		nasm
			nasm boot.asm -o boot.bin
		bximage
			bximage a.img -q -fd -size=1.44
		dd
			dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc
			
小结
	主引导程序的代码量不能超过512字节
	主引导程序需要使用汇编语言开发
	主引导程序中可以通过BIOS中断使用硬件功能
	主引导程序运行于实模式(地址都是实际的物理地址)
	
第3课 调试环境搭建
1，问题
	如何调试主引导区的代码？
	
2，Bochs(另一款优秀的虚拟机软件)
	专业模拟x86架构的虚拟机
	开源且高度可移植，由C++编写完成
	支持操作系统开发过程中的断点调试
	通过简单配置就能够运行于绝大多数主流的操作系统
	
	小贴士
		确定bochs的安装路径(which bochs)
		安装vgabios (apt-get install vgabios)
		确定vgabios的安装路径(whereis vgabios)
		
	bochs的启动文件
	启动bochs虚拟机
		显示方式：bochs -f bochsrc_file
		隐式方式：bochs (在当前目录下查找以下三个文件)
			.bochsrc
			bochsrc
			bochsrc.txt
			
3，bochs中的常用调试命令
	b(break)			设置断点				b 0x7c00
	c(continue)			继续执行				c
	s(step)				单步执行				s
	info b(break)		查看当前所有断点		info b
	info cpu			查看当前CPU状态		info cpu
	r(reg)				查看常规寄存器状态	r
	sreg				查看段寄存器状态		sreg
	x /Nuf expression	查看内存中的数据		x /2bx 0x7c00
	trace on[off]		开关：打印执行的指令	trace on
	trace-reg on[off]	开关：打印寄存器的值	trace-reg on
	
第4课 主引导程序的扩展-上
1，限制
	主引导程序的代码量不能超过512字节
	
	突破限制的思路
		主引导程序
			完成最基本的初始化工作
			从存储介质中加载程序到内存中
			将控制权交由新加载的程序执行
			......
		
2，问题
	主引导程序如何加载存储介质中的其它程序？
	
	文件系统
		存储介质上组织文件数据的方法(数据组织的方式)
		FAT12文件格式
			数据区
			根目录区
			FAT2
			FAT1
			引导扇区
			
	文件系统示例
		FAT12是DOS时代的早期文件系统
		FAT12结构非常简单，一直沿用于软盘
		FAT12的基本组织单位
			字节(byte)：基本数据单位
			扇区(Sector)：磁盘中的最小数据单元
			簇(Cluster)：一个或多个扇区
			
	解决方案
		使用FAT12对软盘进行格式化
		编写可执行程序(Loader)，并将其拷贝到软盘中
		主引导程序(Boot)在文件系统中查找Loader
		将Loader复制到内存中，并跳转到入口处执行
		
	实验：往虚拟软盘中写入文件
		原材料：FreeDOS，Bochs，bximage
		步骤：
			创建虚拟软盘data.img
			在FreeDos中进行格式化(FAT12)
			将data.img挂载到Linux中，并写入文件
			
	下一步的工作
		Boot查找目标文件(Loader)，并读取文件的内容
		
3，深入FAT12文件系统
	FAT12文件系统由引导区，FAT表，根目录项表和文件数据区组成
		扇区位置		长度			内容
		  0			1(512 B)	引导程序
		  1			9(4608 B)	FAT表1
		  10		9(4608 B)	FAT表2
		  19		14(9728 B)	目录文件项
		  33		----		文件数据
		  
	FAT12的主引导区
		主引导区存储的比较重要的信息是文件系统的类型，文件系统逻辑扇区总数，
		每簇包含的扇区数，等。主引导区最后以0x55aa两个字节作为结束，共占用一个扇区。
		
4，实验：读取data.img中的文件系统信息
	步骤：
		创建Fat12Header结构体类型
		使用文件流读取前512字节的内容
		解析并打印相关的信息
		
	实验结论
		(1) FreeDos中的format程序在格式化软盘的时候自动在第0扇区生成了一个主引导程序，
			这个主引导程序只打印一个字符串
		(2) 文件格式和文件系统都是用于定于数据如何存放的规则，只要遵循这个规则就能够成功
			读写目标数据
			
小结
	主引导程序的代码量不能超过512字节
	可以通过主引导程序加载新程序的方式突破限制
	加载新程序需要依赖于文件系统
	FAT12是一种早期用于软盘的简单文件系统
	FAT12文件系统的重要信息存储于0扇区
	
第5课 主引导程序的扩展-下
1，问题
	如何在FAT12根目录中查找是否存在目标文件？
	
	根目录区的大小和位置
		大小：	BPB_RootEntCnt * sizeof(RootEntry)
				----------------------------------
						BPB_BytsPerSec
		位置：在第19个扇区的起始位置
	
	FAT12文件系统中的根目录区
		根目录区由目录项构成，每一个目录项代表根目录中的一个文件索引。
		数据成员			偏移		长度		描述
		DIR_Name		0x00	0x0B	文件名8字节，扩展名3字节
		DIR_Attr		0x0B	0x01	文件属性
		Reserve			0x0C	0x0A	保留位
		DIR_WrtTime		0x16	0x02	最后一次写入时间
		DIR_WrtDate		0x18	0x02	最后一次写入日期
		DIR_FstClus		0x1A	0x02	文件开始的簇号(在FAT12中1簇是1扇区)
		DIR_FileSize	0x1C	0x04	文件大小
		(RootEntry数据结构共32字节)
		
	实验：读取FAT12文件系统的根目录信息
		步骤：
			创建RootEntry结构体类型
			使用文件流顺序读取每个目录项的内容
			解析并打印相关的信息
			
2，目录项中的关键成员
	DIR_Name
		文件名(用于判断是否为目标文件)
	DIR_FstClus
		文件数据起始存储位置(用于确定读取位置)
	DIR_FileSize
		文件大小(用于确定读取的字节数)
		
3，FAT表-FAT12的数据组织核心
	FAT1和FAT2是相互备份的关系，数据内容完全一致
	FAT表是一个关系图，记录了文件数据的先后关系
	每一个FAT表占用12比特
	FAT表的前2个表规定不能使用
	
	FAT表中的先后关系
		以簇(扇区)为单位存储文件数据
		每个表项(vec[i])表示文件数据的实际位置(簇)
			DIR_FstClus表示文件第0簇(扇区)的位置
			vec[DIR_FstClus]表示文件第1簇(扇区)的位置
			vec[vec[DIR_FstClus]]表示文件第2簇(扇区)的位置
			......
			
	实验：加载FAT12中的文件数据
		步骤：
			在根目录区查找目标文件对应的项
			获取目标文件的起始簇号和文件大小
			根据FAT表中记录的逻辑先后关系读取数据
	小贴士一
		FAT表中每个表项只占用12比特(1.5字节)
		FAT表一共记录了BPB_BytsPerSec * 9 * 2/3个表项
		可以使用一个short表示一个表项的值
		如果表项值大于等于0xFF8，则说明已经到达最后一个簇
		如果表项值等于0xFF7，则说明当前簇已经损坏
	小贴士二
		数据区起始簇(扇区)号为33，地址为0x4200
		数据区起始地址所对应的编号为2(不为0)
		因此，DIR_FstClus对应的地址为：
			0x4200 + (DIR_FstClus - 2) * 512

小结
	FAT12根目录区记录了文件的起始簇号和长度
	通过查找根目录区能够确定是否存在目标文件
	FAT12文件数据的组织使用了单链表的思想
		文件数据离散的分布于存储介质中
		文件数据通过FAT项进行关联

第6课 突破512字节的限制-上
	突破限制的准备工作
		辅助函数：字符串打印，软盘读取
		
	BIOS中的字符串打印
		指定打印参数(AX = 0x1301, BX = 0x0007)
		指定字符串的内存地址(ES:BP = 串地址)
		指定字符串的长度(CX = 串长度)
		中断调用( int 0x10 )
		
	字符串打印示例
		// 指定字符串地址
		mov ax, msg
		mov bp, ax
		mov ax, ds
		mov es, ax
		// 指定字符串长度
		mov cx, 6
		// 指定打印参数
		mov ax, 0x1301
		mov bx, 0x0007
		int 0x10
		
	汇编小贴士
		汇编中可以定义函数(函数名使用标签定义)
			call function
			函数体的最后一条指令为ret
		如果代码中定义了函数，那么需要定义栈空间
			用于保存关键寄存器的值
			栈顶地址通过sp寄存器保存
		汇编语言中的“常量定义”(equ)
			用法：const equ 0x7c00 ; #define const 0x7c00
			与dx(db, dw, dd)的区别：
				dx定义占用相应的内存空间
				equ定义不会占用任何内存空间

2，问题
	主引导程序中如何读取指定扇区处的数据？
	
	软盘的构造
		一个软盘有 2 个盘面，每个盘面对应 1 个磁头
		每个盘面被划分为若干个圆圈，成为柱面(磁道)
		每个柱面被划分为若干个扇区，每个扇区512字节
		
	3.5寸软盘的数据特性
		每个盘面一共有 80 个柱面(编号为 0-79)
		每个柱面有18个扇区(编号为 1-18)
		存储大小：
			2 * 80 * 18 * 512 = 1474560 bytes = 1440 KB
	
	软盘数据的读取
		软盘数据以扇区(512字节)为单位进行读取
		指定数据所在位置的磁头号，柱面号，扇区号
		计算公式：
			逻辑扇区号		商Q 磁头号：Q & 1	柱面号：Q >> 1
			---------  -->
			柱面扇区数		余R -> 扇区号：R + 1
			
	BIOS中软盘数据读取(int 0x13)
		中断号：0x13
		参数						功能说明
		AH=0x00					软驱复位
		DL=驱动器号(0表示A盘)
		
		AH=0x02					从磁盘将数据读入
		AL=长度(扇区)			ES:BX指向的内存中
		CH=柱面号 CL=起始扇区号
		DH=磁头号 DL=驱动器号
		ES:BX=目标地址 
		
	软盘数据读取流程：
	开始 -> 指定逻辑扇区号(AX)；指定读取扇区数(CX) -> 指定内存位置(ES:BX) -> 重置软驱状态
	-> 根据逻辑扇区计算：柱面号，磁头号，扇区号 -> int 0x13 -> ret
	
	汇编小贴士
		汇编中的16位除法操作(div)
			被除数放到 AX 寄存器
			除数放到通用寄存器或内存单元(8位)
			结果：商位于AL，余数位于AH
			
第7课 突破512字节的限制-中
1，整体思路
	将根目录区加载进入内存 -> 在根目录中查找目标文件 -> 存在？ ->(否) 打印错误信息 -> 结束
														(是) 通过FAT表项将文件内容加载进内存
														-> 执行跳转 -> 结束
														
	汇编小贴士
		汇编中的比较与跳转
			比较：
				cmp cx, 0 ;比较cx的值是否为0
			跳转：
				jz equal ;如果比较结果为真，则跳转到equal标签处
		访问栈空间中的栈顶数据
			不能使用sp直接访问栈顶数据
			通过其它通用寄存器间接访问栈顶数据	
			
小结
	可通过查找根目录区判断是否存在目标文件
		加载根目录区至内存中(ReadSector)
		遍历根目录区的每一项(FindEntry)
		通过每一项的前11个字节进行判断(MemCmp)
		当目标不存在时，打印错误信息
	
第8课 突破512字节的限制-下
1，最后的冲刺
	备份目标文件的目录信息(MenCpy)
	加载FAT表，并完成FAT表项的查找与读取(FatVec)
	
	MemCpy实现要点：拷贝方向(源地址和目的地址重叠)
	
	汇编小贴士
		汇编指令		功能
		ja			>
		jna			<=
		jb			<
		jnb			>=
		
		汇编中的16位乘法操作(mul)
			被乘数放到al寄存器
			乘数放到通用寄存器或内存单元(8位)
			相乘的结果放到AX寄存器中
			
	反汇编
		ndisasm -o 0x7c00 boot.bin > boot.txt
		
第9课
1，实验步骤
	在虚拟软盘中创建体积较大的文本文件(Loader)
	将Loader的内容加载到BaseOfLoader地址处
	打印Loader中的文本(判断加载是否完全)
	
2，第一个Loader程序
	起始地址0x9000 (org 0x9000)
	通过int 0x10在屏幕上打印字符串
	
	汇编小贴士：标识寄存器
    15 14 13 12 11  10  9  8  7  6  5  4  3  2  1  0
                OF  DF  IF TF SF ZF    AF    PF    CF
    ZF:零标志位
    	判断运算的结果是否为0
    	当运算结果为0时，ZF位的值为1
    
    jxx代表了一个指令族，功能是根据标志位进行调整
    	jo当OF为1则跳转
    	jc当CF为1则跳转
    	jns当SF不为1则跳转
    	jz当ZF为2则跳转
    	je比较结果为相等则跳转(即：jz)
    	
小结
	Boot需要进行重构保证在512字节内完成功能
	在汇编程序中尽量确保函数调用前后通用寄存器的状态不变
	Boot成功加载Loader后将控制权转移
	Loader程序没有代码体积上的限制
	
第10课 实模式到保护模式-上
1，CPU历史的里程碑-8086
	地址线宽度为20位，可访问1M内存空间
	引入[段地址：偏移地址]的内存访问方式
		8086的段寄存器和通用寄存器为16位
		单个寄存器寻址最多访问64K的内存空间
		需要两个寄存器配合，完成所有内存空间的访问
		
	深入解析[段地址：偏移地址]
		硬件所做的工作
			段地址左移4位，构成20位的基地址(起始地址)
			基地址 + 偏移地址 = 实地址
		对于开发者的意义
			更有效的划分内存的功能(数据段，代码段，等)
			当出现程序地址冲突时，通过修改段地址解决冲突
			
2,8086时期应用程序中的问题
	1MB内存完全不够用(内存在任何时期都不够用)
	开发者在程序中大量使用内存回卷技术(HMA地址被使用)
	应用程序之间没有界限，相互之间随意干扰
		A程序可以随意访问B程序中的数据
		C程序可以修改系统调度程序的指令
		
	80286的登场
		8086已经有那么多应用程序了，所以必须兼容再兼容
		加大内存容量，增加地址线数量(24位)
		[段地址：偏移地址]的方式可以强化一下
			为每个段提供更多属性(如：范围，特权级，等)
			为每个段的定义提供固定方式
			
	80286之后的工作模式
	实模式							保护模式
	兼容8086的工作方式				新的工作方式
	实地址=(段寄存器<<4)+偏移地址		内存地址=段起始地址+偏移地址
	任意内存随意访问					每个段增加各种属性描述，保证安全性
	
3，初识保护模式
	每一段内存拥有一个属性定义(描述符Descriptor)
	所有段的属性定义构成一张表(描述符表 Descriptor Table)
	段寄存器保存的是属性定义在表中的索引(选择子Selector)
	......
	
	进入保护模式的方式
		定义描述符表
		打开A20地址线
		加载描述符表
		通知CPU进入保护模式
		
第11课 实模式到保护模式-中
1,80286的光荣退场
	历史意义
		引入了保护模式，为现代操作系统和应用程序奠定了基础
	奇葩设计
		段寄存器为24位，通用寄存器为16位(不伦不类)
			理论上，段寄存器中的数值可以直接作为段基址
			16位通用寄存器最多可访问64K的内存
			为了访问16M内存，必须不停切换段基址
			
2,80386的登场(计算机新时期的标识)
	32位地址总线(可支持4G的内存空间)
	段寄存器和通用寄存器都为32位
		任何一个寄存器都能访问到内存的任意角落
			开启了平坦内存模式的新时代
			段基址为0，使用通用寄存器访问4G内存空间
			
3，新时期的内存使用方式
	实模式
		兼容8086的内存使用方式(指哪打哪)
	分段模式
		通过[段地址：偏移地址]的方式将内存从功能上分段(数据段，代码段)
	平坦模式
		所有内存就是一个段[0：32位偏移地址]
		
4，段属性定义
	标识符		值		意义
	DA_32		0x4000	保护模式下32位段
	DA_DR		0x90	只读数据段
	DA_DRW		0x92	可读写数据段
	DA_DRWA		0x93	已访问可读写数据段
	DA_C		0x98	只执行代码段
	DA_CR		0x9A	可执行可读代码段
	DA_CCO		0x9C	只执行一致代码段
	DA_CCOR		0x9E	可执行可读一致代码段
	
5，选择子属性定义
	15--3			2	1--0
	描述符索引值		TI	RPL
	RPL -> SA_RPL0  equ  0
		   SA_RPL1  equ  1
		   SA_RPL2  equ  2
		   SA_RPL3  equ  3
		   
	TI -> SA_TIG  equ  0; GDT
		  SA_TIL  equ  4; LDT
		  
6，保护模式中的段定义
	%macro Descriptor 3							; 段基址，段界限，段属性
		dw  %2 & 0xFFFF							; 段界限1
		dw  %1 & 0xFFFF							; 段基址1
		db  (%1 >> 16) & 0xFF					; 段基址2
		dw  ((%2 >> 8) & 0xF00) | (%3 & 0xF0FF)	; 属性1 + 段界限2 + 属性2
		db  (%1 >> 24) & 0xFF					; 段基址3
	%endmacro									; 共8个字节
	注：dw = 2db，占两个字节空间
	
	段定义结构高32位：
	31-24  23  22  21  20  19-16  15  14-13  12  11-8  7-0
	段基址 G   D/B  L  AVL 段界限  P   DPL    S   TYPE  段基址
	31-24                  19-16                       23-16
	段定义结构低32位：
	31---16     15---0
	段基址15-0   段界限15-0
	
	保护模式中的段定义
	; GDT 定义
	;                         段基址   段界限            属性
	GDT_ENTRY   :  Descriptor  0,        0,                0
	CODE32_DES  :  Descriptor  0,    SegCode32Len - 1,    DA_C + DA_32
	; ......
	
	GdtLen   equ    $ - GDT_ENTRY    ; GDT 长度
	GdtPtr:
		dw   GdtLen - 1		; GDT 界限
		dd   0				; GDT 基地址，需要重新计算
		
7，汇编小贴士
	section关键字用于“逻辑的”定义一段代码集合
	section定义的代码段不同于[段地址：偏移地址]的代码段
		section定义的代码段仅限于源码中的代码段(代码节)
		[段地址：偏移地址]的代码段指内存中的代码段
		[SECTION .s1]
			var1  db  0x1
		[SECTION .s1]
			var2  db  0x2
		[SECTION .s1]
			var3  db  0x3
		==>>
		0x01020000  0x03
		  .s1        .s2
		.s1到.s2需要4字节对齐，需要.s1需要补4个0
		
	[bits 16]
		用于指示编译器将代码按照16位方式进行编译
	[bits 32]
		用于指示编译器将代码按照32位方式进行编译
		
	注意事项
		段描述表中的第0个描述符不使用(仅用于占位)
		代码中必须显示的指明16位代码段和32位代码段
		必须使用jmp指令从16位代码段跳转到32位代码段
		
8，问题
	为什么不直接使用标签定义描述符中的段基地址？
	为什么16位代码段到32位代码段必须无条件跳转？
	
	需要掌握的重点
		NASM将汇编文件当成一个独立的代码段编译
		汇编代码中的标签(Lable)代表的是段内偏移地址
		实模式下需要配合段寄存器中的值计算标签的物理地址
		
	小知识
		流水线技术
			处理器为了提高效率将当前指令和后续指令预取到流水线
			因此，可能同时预取的指令中既有16位代码又有32位代码
			为了避免将32位代码用16位的方式进行，需要刷新流水线
			无跳转跳转jmp能强制刷新流水线
			...
			
小结
	80386处理器是计算机发展史上的里程碑
	32位的寄存器和地址总线能够直接访问4G内存的任意角落
	需要在16位实模式中对GDT中的数据进行初始化
	代码中需要为GDT定义一个标识数据结构(GdtPtr)
	需要使用jmp指令从16位代码跳转到32位代码
	
第12课 实模式到保护模式-下
1，为什么需要dword？
	; 16 bits code
	; ...
	; jump to 32 bits code
	jmp dword Code32Selector : 0
	
	; 32 bits code
	; ...
	
	不一般的jmp (s16 -> s32)
		在16位代码中，所有的立即数默认为16位
		从16位代码段跳转到32位代码段时，必须做强制转换
		否则，段内偏移地址可能被截断
		; 16 bits code
		; ...
		; jump to 32 bits code
		jmp Code32Selector : 0x12345678	; OOPS

		; 32 bits code
		; ...
		
2，深入保护模式：定义显存段
	为了显示数据，必须存在两大硬件：显卡 + 显示器
		显卡
			为显示器提供需要显示的数据
			控制显示器的模式和状态
		显示器
			将目标数据以可见的方式呈现在屏幕上
			
	显存的概念和意义
		显卡拥有自己内部的数据存储器，简称显存
		显存在本质上和普通内存无差别，用于存储目标数据
		操作显存中的数据将导致显示器上内容的改变
	显卡的工作模式：文本模式 & 图形模式
		在不同的模式下，显卡对显存内容的解释是不同的
		可以使用专属指令或int 0x10中断改变显卡工作模式
		在文本模式下：
			显存的地址范围映射为：[0xB8000, 0xBFFFF]
			一屏幕可以显示25行，每行80个字符
	文本模式下显示字符
		CODE32_SEGMENT:
			mov ax, VideoSelector
			mov gs, ax					; 显存段选择子
			
			mov edi, (80 * 12 + 38) * 2	; 屏幕第12行，第38列
			mov ah, 0x0c				; 0000 : 黑底  1100 : 红字
			mov al, 'P'					; 显示字符 P
			mov [gs:edi], ax			;
			
			jmp $
			
	小目标
		在保护模式下，打印指定内存中的字符串
			定义全局堆栈段(.gs)，用于保护模式下的函数调用
			定义全局数据段(.dat)，用于定义只读数据(D.T.OS!)
			利用对显存段的操作定义字符串打印函数(PrintString)
			
	汇编小贴士
		32位保护模式下的乘法操作(mul)
			被乘数放到AX寄存器
			乘数放到通用寄存器或内存单元(16位)
			相乘的结果放到EAX寄存器中
		再论 $ 和 $$
			$表示当前行相对于代码起始位置处的偏移量
			$$表示当前代码节(section)的起始位置
				[section .dat]
				[bits 32]
					DTOS        db  "D.T.OS!", 0
					; 计算DTOS在当前代码节中的偏移位置
					DTOS_OFFSET  equ  DTOS - $$
		
第13课 从保护模式返回实模式
1，这里有“Bug”吗？
    mov ax, VideoSelector
    mov gs, ax
    ----------------
    mov ax, StackSelector
    mov ss, ax
    ------------------
    mov ax, Data32Selector
    mov ds, ax
    
    mov ebp, DTOS_OFFSET
    mov bx, 0x0C
    mov dh, 12
    mov dl, 33
    ----------------
    call PrintString
	----------------
	
	指定栈段选择子之后，就可以直接进行函数调用吗？
	在16位代码段已经给esp栈顶指针进行了赋值
	
2，保护模式下的栈段( Stack Segment )
	指定一段空间，并为其定义段描述符
	根据段描述符表中的位置定义选择子
	初始化栈段寄存器( ss <- StackSlector )
	初始化栈顶指针( esp <- TopOfStack )
	
3，是否能够从保护模式返回实模式？如果可以，如何完成跳转？
	80x86中一个神秘限制
		无法直接从32位代码段回到实模式
		只能从16位代码段间接返回实模式
		在返回前必须用合适的选择子对段寄存器赋值

	处理器中的设计简介
		80286之后的处理器都兼容8086的实模式
		然而，绝大多时候处理器都运行于保护模式
		因此，保护模式的运行效率至关重要
		那么，处理器如何高效的访问内存中的段描述符？
		
	解决方案：高速缓冲存储器
		当使用选择子设置段寄存器时
			根据选择子访问内存中的段描述符
			将段描述符加载到段寄存器的高速缓冲存储器
			需要段描述符信息时，直接从高速缓冲存储区中获得
			
	思考
		当处理器运行于实模式时，段寄存器的高速缓冲存储器是否会用到？
		
	注意事项！！！
		在实模式下，高速缓冲存储器仍然发挥着作用
		段基址是32位，其值是相应段寄存器的值乘以16
		实模式下段基址有效位为20位，段界限固定为0xFFFF( 64K )
		段属性的值不可设置，只能继续沿用保护模式下所设置的值
		
	因此，当从保护模式返回实模式时：
		通过加载一个合适的描述符选择子到有关段寄存器，以使得对应
		段描述符高速缓冲寄存器中含有合适的段界限和属性！！
		
	返回实模式的流程
	32位保护模式代码段 -----> 16位保护模式代码段 ------> 16位实模式代码段
							1，刷新段寄存器				1，设置段寄存器的值
							2，退出保护模式				2，关闭A20地址线
														3，启用硬件中断
														
	汇编小贴士：深入jmp指令
	段内跳转
				操作码( 1 byte )		操作数( 2 bytes )
		低地址   E9					段内偏移地址			高地址
		
	段间跳转
				操作码( 1 byte )		操作数( 4 bytes )
		低地址   EA				偏移地址	   段基址		高地址
		
小结
	定义保护模式的栈段时，必须设置段选择子和栈顶指针
	从保护模式能够间接跳转返回实模式
	在实模式下，仍然使用高速缓冲存储器中的数据做有效性判断
	通过运行时修改指令中的数据能够动态决定代码的行为
	
第14课 局部段描述符表的使用
1，什么是LDT( Local Descriptor Table )
	局部段描述符表
		本质是一个段描述符表，用于定义段描述符
		与GDT类似，可以看做“段描述符的数组”
		通过定义选择子访问局部段描述符表中的元素
		
	局部段描述符的选择子
		15----3			2		1---0
		描述符索引值    1		RPL
		LDT选择子的第二位恒为1
	
	注意事项
		局部段描述符表需要在全局段描述符表中注册(增加描述项)
		通过对应的选择子加载局部段描述符( lldt )
		局部段描述符表从第 0 项开始使用(和GDT不同，GDT第0项需要保留)
		
2，LDT具体用来干什么？ 为什么还需要一个“额外的”段描述符表？
	LDT的意义
		代码层面的意义
			分级管理功能相同意义不同的段(如：多个代码段)
		系统层面的意义
			实现多任务的基础要素(每个任务对应一系列不同的段)
			
3，LDT的定义与使用
	定义独立功能相关的段(代码段，数据段，栈段)
	将目标段描述符组成局部段描述符表(LDT)
	为各个段描述符定义选择子(SA_TIL)
	在GDT中定义LDT的段描述符，并定义选择子
	
小结
	局部段描述表用于组织功能相关的段(section)
	局部段描述符需要加载后才能正常使用(lldt)
	局部段描述符表必须子啊全局段描述符表中注册(Descriptor)
	通过局部段描述符表的选择子对其进行访问
	局部段描述符表是实现多任务的基础
	
第15课 保护模式中的特权级-上
1，保护模式小结
	使用选择子访问段描述符表时，索引值的合法性检测
		当索引值越界时，引发异常
		判断规则：索引值 * 8 + 7 <= 段描述符表界限值
		
	内存段类型合法性检测
		具备可执行属性的段(代码段)只能加载到 CS 寄存器
		具备可写属性的段(数据段)才能加载到 SS 寄存器
		具备可读属性的段才能加载到 DS，ES，FS，GS 寄存器
		
	代码段和数据段的保护
		处理器每访问一个地址都要确认该地址不超过界限值
		判断规则：
			代码段：IP + 指令长度 <= 代码段界限
			数据段：访问起始地址 + 访问数据长度 <= 数据段界限
			
	注意
		保护模式中代码中定义的界限值通常为：最大偏移地址值(相对于段基地址)
		
2，保护模式除了利用段界限对内存访问进行保护，是否还提供其它的保护机制？
	保护模式中的特权级
		x86架构中的保护模式提供了4个特权级(0, 1, 2, 3)
		特权级从高到低分别为0，1，2，3 (数字越大特权级越低)
		内核：Level0; 系统程序：Level1, Level2; 应用程序：Level3

	特权级的表现形式
		CPL ( Current Privilege Level )
			当前可执行代码段的特权级，由CS寄存器最低2位定义
		DPL ( Descriptor Privilege Level )
			内存段的特权级，在段描述符表中定义
		RPL ( Request Privilege Level )
			选择子的特权级，由选择子最低2位定义
			
3，初探特权级
	段描述符中的DPL用于标识内存段的特权级；可执行代码访问内存段时必须满足一定特权级( CPL ),
	否则，处理器将产生异常。
	
	CPL和DPL的关系
		保护模式中，每一个代码段都定义了一个DPL
		当处理器从A代码段成功跳转到B代码段执行
			跳转之前：CPL = DPL(A)
			跳转之后：CPL = DPL(B)
			
		保护模式中，每一个数据段都定义了一个DPL
		当处理器执行过程中需要访问数据段时：
			CPL <= DPL(data)
		
	实验结论
		处理器进入保护模式后CPL = 0 (最高特权级)
		处理器不能直接从高特权级转换到低特权级执行
		选择子RPL大于对应段描述符的DPL时，产生异常
		
小结
	保护模式对内存的访问范围有严格定义
	保护模式定义了内存段的特权级(0, 1, 2, 3)
		每个内存段都有固定的特权级( DPL )
		不同代码段之间成功跳转后，CPL可能发生改变
		CPL小于或等于数据段DPL才能成功访问数据
		
第16课 保护模式中的特权级-中
1，如何在不同特权级的代码段之间跳转执行？
	一种新的描述符：门描述符( Gate Descriptor )
		通过门描述符在不同特权级的代码间进行跳转
		根据应用场景的不同，门描述符分为：
			调用门( Call Gates )
			中断门( Interrupt Gates )
			陷阱门( Trap Gate )
			人物门( Task Gate )
			
	门描述符的内存结构
		每一个门描述符占用8字节内存
		不同类型门描述的内存含义不同
		高32位：
		31-24  23  22  21  20  19-16  15  14-13  12  11-8  7  6  5 4-0
			                          P   DPL    S   TYPE  0  0  0
		低32位：
		31---16     15---0
		
	调用门描述符( call gates )的定义
		高32位：
		31-16        15  14-13  12  11-8  7  6  5  4-0
		偏移地址2	 P   DPL    S   TYPE  0  0  0  Param Count
		低32位：
		31---16     15---0
	    选择子      偏移地址1

2，汇编小贴士
	汇编语言中的跳转方式
		段内跳转：call， jmp
			参数为相对地址，函数调用时只需要保存当前偏移地址
		段间跳转：call far， jmp far
			参数为选择子和偏移地址
			函数调用时需要同时保存段基地址和偏移地址 
			
4，实验结论
	门描述符是一种特殊的描述符，需要注册于段描述符表
	调用门可以看做一个函数指针(保存具体函数的入口地址)
	通过调用门选择子对相应的函数进行远调用( call far )
	可以直接使用 选择子：偏移地址 的方式调用其它段的函数
	使用调用门时偏移地址无意义，仅仅是语法需要
	
5，保护模式下的不同段之间如何进行代码复用？
	解决方案
		将不同代码段需要复用的函数定义到独立的段中( retf )
		计算每一个可复用函数的偏移量( Funcname - $$ )
		通过 段选择子：偏移地址 的方式对目标函数进行远程调用
		
小结
	门描述符是一种特殊的描述符，需要注册于段描述符表
	门描述符分为：调用门，中断门，陷阱门，任务门
	调用门可以看做一个函数指针(保存具体函数的入口地址)
	调用门选择子对应的函数调用方式为远调用( call far )
	
第17课 保护模式中的特权级-下
1，使用调用门如何实现不同特权级之间的跳转？
	不幸的事实
		调用门只支持从低特权级跳转到高特权级执行
		无法利用调用门从高特权级跳转到低特权级执行
		
	调用门的特权级跳转分析
		DPL = 3  ---- call far --> 调用门 -----> DPL = 0
		低特权级									高特权级
		代码段	<-------- return far ----------	代码段
		
	思路整理
		调用门的特权级跳转
			通过远调用( call far ): 低特权级 -> 高特权级
			通过远返回( retf ): 高特权级 -> 低特权级
		远返回(retf)能够实现高特权级到低特权级的代码跳转，那么，
		考虑如何利用其机制完成这个跳转！！
		
	需要提前知道的事实
		x86处理器对于不同的特权级需要使用不同的栈
		每一个特权级对应一个私有的栈(最多4个栈)
		特权级跳转变化之前必须指定好相应的栈
		
	解决方案(高特权级 -> 低特权级)
		指定目标栈段选择子(push)
		指定栈顶指针位置(push)
		指定目标代码段选择子(push)
		指定目标代码段偏移(push)
		跳转(retf)
		
小结
	调用门只支持从低特权级跳转到高特权级执行
	利用远返回( retf )可以从高特权级转移到低特权级
	x86处理器中每一个特权级对应一个私有的栈
	特权级跳转变化之前必须指定好相应的栈
	
第18课 深入特权级转移-上
1，初识任务状态段( Task State Segment )
	处理器所提供的硬件数据结构，用于实现多任务解决方案
	TSS中保存了关键寄存器的值以及不同特权级使用的栈
		段寄存器
		通用寄存器
		不同特权级的栈信息
		
	TSS中不同特权级的栈信息
		在TSS中保存了3个栈信息
			特权级0：ss0, esp0	| 高地址
			特权级1：ss1, esp1	|
			特权级2：ss2, esp2 \|/ 低
			
	特权级转移时的栈变化
		低特权级 -> 高特权级(调用门)
			从TSS获取高特权级目标栈段
			将低特权级栈信息压入高特权级栈中(ss和esp)
		高特权级 -> 低特权级(retf)
			将低特权级栈信息从高特权级栈中取出并恢复到ss和esp
			
2，目标实验(操作系统雏形)
	低特权级 <--> 高特权级
		定义32位核心代码段和数据段( Privilege = 0 )
		定义32位任务代码段和数据段( Privilege = 3 )
		由核心代码段跳转到任务代码段执行(高 -> 低)
		在任务代码段中调用高特权级代码段打印字符串( Call Gate )
	
									DPL = 0
	DPL = 3	<------ return far ----	核心代码段
			 
	任务		--- call far 调用门 -->	DPL = 0
	代码段  <------ return far ---- 系统函数
	
	注意事项
		特权级转移时会发生栈的变换(如何变换？)
		栈的变化需要在TSS结构体中预先定义
		TSS结构体作为一个独立段定义(描述符，选择子)
		在核心代码段中加载具体的TSS结构体( ltr TSSSelector )
		
3，RPL究竟是什么？有什么用？
	RPL的意义
		位置意义
			选择子或段寄存器的最低2位
		请求意义
			资源请求的特权级(不同于当前特权级CPL)
	当需要请求获取某种资源时，处理器通过CPL，RPL和DPL共同确定请求是否合法
		当前代码CPL -> 选择子RPL -> 数据段DPL
		
小结
	TSS是通过调用门转移到高特权级执行的关键
	TSS是处理器的硬件数据结构，用于实现多任务
	TSS结构体遵循保护模式下内存使用的规则
	RPL在请求资源时是合法判断的依据之一
	处理器使用CPL，RPL和DPL共同确定合法性

		

